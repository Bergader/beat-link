meta:
  id: pdb_file
  title: DeviceSQL database export (probably generated by rekordbox)
  application: rekordbox
  file-extension:
    - pdb
  license: EPL-1.0
  endian: le

doc: |
  This is a relational database format designed to be efficiently used
  by very low power devices (there were deployments on 16 bit devices
  with 32K of RAM). Today you are most likely to encounter it within
  the Pioneer Professional DJ ecosystem, because it is the format that
  their rekordbox software uses to write USB and SD media which can be
  mounted in DJ controllers and used to play and mix music.

  It has been reverse-engineered to facilitate sophisticated
  integrations with light and laser shows, videos, and other musical
  instruments, by supporting deep knowledge of what is playing and
  what is coming next through monitoring the network communications of
  the players.

  The file is divided into fixed-size blocks. The first block has a
  header that establishes the block size, and lists the tables
  available in the database, identifying their types and the index of
  the first of the series of linked pages that make up that table.

  Each table is made up of a series of rows which may be spread across
  any number of pages. The pages start with a header describing the
  page and linking to the next page. The rest of the page is used as a
  heap: rows are scattered around it, and located using an index
  structure that builds backwards from the end of the page. Each row
  of a given type has a fixed size structure which links to any
  variable-sized strings by their offsets within the page.

  As changes are made to the table, some records may become unused,
  and there may be gaps within the heap that are too small to be used
  by other data. There is a bit map in the row index that identifies
  which rows are actually present. Rows that are not present must be
  ignored: they do not contain valid (or even necessarily well-formed)
  data.

  The majority of the work in reverse-engineering this format was
  performed by @henrybetts and @flesniak, for which I am hugely
  grateful. @GreyCat helped me learn the intricacies (and best
  practices) of Kaitai far faster than I would have managed on my own.

doc-ref: https://github.com/Deep-Symmetry/dysentery/blob/master/doc/Analysis.pdf

seq:
  - contents: [0, 0, 0, 0]
  - id: len_page
    type: u4
    doc: |
      The database page size, in bytes. Pages are referred to by
      index, so this size is needed to calculate their offset, and
      table pages have a row index structure which is built from the
      end of the page backwards, so finding that also requires this
      value.
  - id: num_tables
    type: u4
    doc: |
      Determines the number of table entries that are present. Each
      table is a linked list of pages containing rows of a particular
      type.
  - id: next_unused_page
    type: u4
    doc: |
      @flesinak said: "Not used as any `empty_candidate`, points
      past the end of the file."
  - type: u4
  - id: sequence
    type: u4
    doc: |
      @flesniak said: "Always incremented by at least one,
      sometimes by two or three."
  - contents: [0, 0, 0, 0]
  - id: tables
    type: table
    repeat: expr
    repeat-expr: num_tables
    doc: |
      Describes and links to the tables present in the database.

types:
  table:
    doc: |
      Each table is a linked list of pages containing rows of a single
      type. This header describes the nature of the table and links to
      its pages by index.
    seq:
      - id: type
        type: u4
        enum: page_type
        doc: |
          Identifies the kind of rows that are found in this table.
      - id: empty_candidate
        type: u4
      - id: first_page
        type: page_ref
        doc: |
          Links to the chain of pages making up that table. The first
          page seems to always contain similar garbage patterns and
          zero rows, but the next page it links to contains the start
          of the meaningful data rows.
      - id: last_page
        type: page_ref

  page_ref:
    doc: |
      An index which points to a table page (its offset can be found
      by multiplying the index by the `page_len` value in the file
      header). This type allows the linked page to be lazy loaded.
    seq:
      - id: index
        type: u4
        doc: |
          Identifies the desired page number.
    instances:
      body:
        doc: |
          When referenced, loads the specified page and parses its
          contents appropriately for the type of data it contains.
        io: _root._io
        pos: _root.len_page * index
        size: _root.len_page
        type: page

  page:
    doc: |
      A table page, consisting of a short header describing the
      content of the page and linking to the next page, followed by a
      heap in which row data is found. At the end of the page there is
      an index which locates all rows present in the heap via their
      offsets past the end of the page header.
    seq:
      - id: header
        type: page_header

    instances:
      num_row_indices:
        value: header.num_rows / 16 + 1
      row_index_chain:
        pos: '_root.len_page - 4'
        type: 'row_flags(num_row_indices - 1, _root.len_page - 4)'

  page_header:
    seq:
      - id: empty_1
        contents: [0, 0, 0, 0]
      - id: page_index
        doc: Matches the index we used to look up the page, sanity check?
        type: u4
      - id: type
        type: u4
        enum: page_type
        doc: Identifies the type of information stored in the rows of this page.
      - id: next_page
        doc: |
          Index of the next page containing this type of rows. Points past
          the end of the file if there are no more.
        type: page_ref
      - id: unknown_1
        type: u4
        doc: '@flesniak said: "sequence number (0->1: 8->13, 1->2: 22, 2->3: 27)"'
      - id: unknown_2
        size: 4
      - id: num_rows
        type: u1
      - id: unknown_3
        type: u1
        doc: '@flesniak said: "a bitmask (1st track: 32)"'
      - id: unknown_4
        type: u2
        doc: '@flesniak said: "25600 for strange blocks"'
      - id: free_size
        type: u2
        doc: Unused space, excluding index at end of page.
      - id: used_size
        type: u2
      - id: unknown_5
        type: u2
        doc: '@flesniak said: "(0->1: 2)"'
      - id: num_rows_large
        type: u2
        doc: '@flesniak said: "usually <= num_rows except for playlist_map?"'
      - id: unknown_6
        type: u2
        doc: '@flesniak said: "1004 for strange blocks, 0 otherwise"'
      - id: unknown_7
        type: u2
        doc: '@flesniak said: "always 0 except 1 for history pages, num entries for strange pages?"'

  row_flags:
    params:
      - id: num_remaining
        type: u2
      - id: base
        type: u2
    seq:
      - id: entry_enabled_flags
        type: u2
      - id: unknown_flags
        type: u2
    instances:
      rows:
        pos: base - 0x20
        type: row_ref(_index)
        repeat: expr
        repeat-expr: 16
      next:
        pos: base - 0x24
        type: 'row_flags(num_remaining - 1, base - 0x24)'
        if: num_remaining > 0

  row_ref:
    params:
      - id: index
        type: u2
    seq:
      - id: ofs_row
        type: u2
    instances:
      enabled:
        value: '(((_parent.entry_enabled_flags >> (15 -index)) & 1) != 0 ? true : false)'
      body:
        pos: ofs_row + 0x28
        size-eos: true  # TODO: Make an actual object structure based on page data type.
        if: enabled

enums:
  page_type:
    0:
      id: tracks
      doc: |
        Holds records describing tracks, such as their title, artist,
        genre, artwork ID, playing time, etc.
    1:
      id: genres
      doc: Holds records naming musical genres, for reference by tracks and searching.
    2:
      id: artists
      doc: Holds records naming artists, for reference by tracks and searching.
    3:
      id: albums
      doc: Holds records naming albums, for reference by tracks and searching.
    4:
      id: labels
      doc: Holds records naming music labels, for reference by tracks and searching.
    5:
      id: keys
      doc: Holds records naming musical keys, for reference by tracks and searching.
    6:
      id: colors
      doc: Holds records naming color labels, for reference  by tracks and searching.
    7:
      id: playlists
      doc: Holds records containing playlists.
    8:
      id: playlist_map
      doc: TODO figure out and explain
    9:
      id: unknown_9
    10:
      id: unknown_10
    11:
      id: unknown_11
    12:
      id: unknown_12
    13:
      id: artwork
      doc: Holds records pointing to album artwork images.
    14:
      id: unknown_14
    15:
      id: unknown_15
    16:
      id: columns
      doc: TODO figure out and explain
    17:
      id: unknown_17
    18:
      id: unknown_18
    19:
      id: history
      doc: Holds records listing tracks played in performance sessions.
